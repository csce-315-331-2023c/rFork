"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool";
exports.ids = ["vendor-chunks/pg-pool"];
exports.modules = {

/***/ "(ssr)/./node_modules/pg-pool/index.js":
/*!***************************************!*\
  !*** ./node_modules/pg-pool/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch(err => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err);\n    throw err;\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(ssr)/./node_modules/pg/lib/index.js\").Client)\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGctcG9vbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHFCQUFxQiwwREFBOEI7O0FBRW5EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhFQUFvQjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZm9yay8uL25vZGVfbW9kdWxlcy9wZy1wb29sL2luZGV4LmpzPzJjMWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcblxuY29uc3QgTk9PUCA9IGZ1bmN0aW9uICgpIHt9XG5cbmNvbnN0IHJlbW92ZVdoZXJlID0gKGxpc3QsIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCBpID0gbGlzdC5maW5kSW5kZXgocHJlZGljYXRlKVxuXG4gIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IGxpc3Quc3BsaWNlKGksIDEpWzBdXG59XG5cbmNsYXNzIElkbGVJdGVtIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpZGxlTGlzdGVuZXIsIHRpbWVvdXRJZCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5pZGxlTGlzdGVuZXIgPSBpZGxlTGlzdGVuZXJcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHRpbWVvdXRJZFxuICB9XG59XG5cbmNsYXNzIFBlbmRpbmdJdGVtIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd09uRG91YmxlUmVsZWFzZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWxlYXNlIGNhbGxlZCBvbiBjbGllbnQgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiByZWxlYXNlZCB0byB0aGUgcG9vbC4nKVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoUHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHsgY2FsbGJhY2s6IGNhbGxiYWNrLCByZXN1bHQ6IHVuZGVmaW5lZCB9XG4gIH1cbiAgbGV0IHJlalxuICBsZXQgcmVzXG4gIGNvbnN0IGNiID0gZnVuY3Rpb24gKGVyciwgY2xpZW50KSB7XG4gICAgZXJyID8gcmVqKGVycikgOiByZXMoY2xpZW50KVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXMgPSByZXNvbHZlXG4gICAgcmVqID0gcmVqZWN0XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgLy8gcmVwbGFjZSB0aGUgc3RhY2sgdHJhY2UgdGhhdCBsZWFkcyB0byBgVENQLm9uU3RyZWFtUmVhZGAgd2l0aCBvbmUgdGhhdCBsZWFkcyBiYWNrIHRvIHRoZVxuICAgIC8vIGFwcGxpY2F0aW9uIHRoYXQgY3JlYXRlZCB0aGUgcXVlcnlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfSlcbiAgcmV0dXJuIHsgY2FsbGJhY2s6IGNiLCByZXN1bHQ6IHJlc3VsdCB9XG59XG5cbmZ1bmN0aW9uIG1ha2VJZGxlTGlzdGVuZXIocG9vbCwgY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpZGxlTGlzdGVuZXIoZXJyKSB7XG4gICAgZXJyLmNsaWVudCA9IGNsaWVudFxuXG4gICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICBjbGllbnQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbC5sb2coJ2FkZGl0aW9uYWwgY2xpZW50IGVycm9yIGFmdGVyIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGVycm9yJywgZXJyKVxuICAgIH0pXG4gICAgcG9vbC5fcmVtb3ZlKGNsaWVudClcbiAgICAvLyBUT0RPIC0gZG9jdW1lbnQgdGhhdCBvbmNlIHRoZSBwb29sIGVtaXRzIGFuIGVycm9yXG4gICAgLy8gdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCAmIHB1cmdlZCBhbmQgaXMgdW51c2FibGVcbiAgICBwb29sLmVtaXQoJ2Vycm9yJywgZXJyLCBjbGllbnQpXG4gIH1cbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIENsaWVudCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAncGFzc3dvcmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHBhc3N3b3JkIHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsICdwYXNzd29yZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLnBhc3N3b3JkLFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnNzbCAmJiBvcHRpb25zLnNzbC5rZXkpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHNzbC0+a2V5IHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMuc3NsLCAna2V5Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLm1heCA9IHRoaXMub3B0aW9ucy5tYXggfHwgdGhpcy5vcHRpb25zLnBvb2xTaXplIHx8IDEwXG4gICAgdGhpcy5vcHRpb25zLm1heFVzZXMgPSB0aGlzLm9wdGlvbnMubWF4VXNlcyB8fCBJbmZpbml0eVxuICAgIHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUgPSB0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlIHx8IGZhbHNlXG4gICAgdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyA9IHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgfHwgMFxuICAgIHRoaXMubG9nID0gdGhpcy5vcHRpb25zLmxvZyB8fCBmdW5jdGlvbiAoKSB7fVxuICAgIHRoaXMuQ2xpZW50ID0gdGhpcy5vcHRpb25zLkNsaWVudCB8fCBDbGllbnQgfHwgcmVxdWlyZSgncGcnKS5DbGllbnRcbiAgICB0aGlzLlByb21pc2UgPSB0aGlzLm9wdGlvbnMuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMgPSAxMDAwMFxuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudHMgPSBbXVxuICAgIHRoaXMuX2lkbGUgPSBbXVxuICAgIHRoaXMuX2V4cGlyZWQgPSBuZXcgV2Vha1NldCgpXG4gICAgdGhpcy5fcGVuZGluZ1F1ZXVlID0gW11cbiAgICB0aGlzLl9lbmRDYWxsYmFjayA9IHVuZGVmaW5lZFxuICAgIHRoaXMuZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLmVuZGVkID0gZmFsc2VcbiAgfVxuXG4gIF9pc0Z1bGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudHMubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhcbiAgfVxuXG4gIF9wdWxzZVF1ZXVlKCkge1xuICAgIHRoaXMubG9nKCdwdWxzZSBxdWV1ZScpXG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdwdWxzZSBxdWV1ZSBlbmRlZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRoaXMuZW5kaW5nKSB7XG4gICAgICB0aGlzLmxvZygncHVsc2UgcXVldWUgb24gZW5kaW5nJylcbiAgICAgIGlmICh0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9pZGxlLnNsaWNlKCkubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlKGl0ZW0uY2xpZW50KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9jbGllbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZVxuICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSB3YWl0aW5nLCBkbyBub3RoaW5nXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nUXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZygnbm8gcXVldWVkIHJlcXVlc3RzJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBpZGxlIGNsaWVudHMgYW5kIHdlIGhhdmUgbm8gbW9yZSByb29tIGRvIG5vdGhpbmdcbiAgICBpZiAoIXRoaXMuX2lkbGUubGVuZ3RoICYmIHRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0l0ZW0gPSB0aGlzLl9wZW5kaW5nUXVldWUuc2hpZnQoKVxuICAgIGlmICh0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgY29uc3QgaWRsZUl0ZW0gPSB0aGlzLl9pZGxlLnBvcCgpXG4gICAgICBjbGVhclRpbWVvdXQoaWRsZUl0ZW0udGltZW91dElkKVxuICAgICAgY29uc3QgY2xpZW50ID0gaWRsZUl0ZW0uY2xpZW50XG4gICAgICBjbGllbnQucmVmICYmIGNsaWVudC5yZWYoKVxuICAgICAgY29uc3QgaWRsZUxpc3RlbmVyID0gaWRsZUl0ZW0uaWRsZUxpc3RlbmVyXG5cbiAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlQ2xpZW50KGNsaWVudCwgcGVuZGluZ0l0ZW0sIGlkbGVMaXN0ZW5lciwgZmFsc2UpXG4gICAgfVxuICAgIGlmICghdGhpcy5faXNGdWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5ld0NsaWVudChwZW5kaW5nSXRlbSlcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGNvbmRpdGlvbicpXG4gIH1cblxuICBfcmVtb3ZlKGNsaWVudCkge1xuICAgIGNvbnN0IHJlbW92ZWQgPSByZW1vdmVXaGVyZSh0aGlzLl9pZGxlLCAoaXRlbSkgPT4gaXRlbS5jbGllbnQgPT09IGNsaWVudClcblxuICAgIGlmIChyZW1vdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZW1vdmVkLnRpbWVvdXRJZClcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gdGhpcy5fY2xpZW50cy5maWx0ZXIoKGMpID0+IGMgIT09IGNsaWVudClcbiAgICBjbGllbnQuZW5kKClcbiAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIGNsaWVudClcbiAgfVxuXG4gIGNvbm5lY3QoY2IpIHtcbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2Fubm90IHVzZSBhIHBvb2wgYWZ0ZXIgY2FsbGluZyBlbmQgb24gdGhlIHBvb2wnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvIGNvbm5lY3QgYSBuZXcgY2xpZW50LCBkb24ndCBkbyBzb1xuICAgIGlmICh0aGlzLl9pc0Z1bGwoKSB8fCB0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBpZGxlIGNsaWVudHMgc2NoZWR1bGUgYSBwdWxzZSBpbW1lZGlhdGVseVxuICAgICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5fcHVsc2VRdWV1ZSgpKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nUXVldWUucHVzaChuZXcgUGVuZGluZ0l0ZW0ocmVzcG9uc2UuY2FsbGJhY2spKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSAoZXJyLCByZXMsIGRvbmUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpZClcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2soZXJyLCByZXMsIGRvbmUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gbmV3IFBlbmRpbmdJdGVtKHF1ZXVlQ2FsbGJhY2spXG5cbiAgICAgIC8vIHNldCBjb25uZWN0aW9uIHRpbWVvdXQgb24gY2hlY2tpbmcgb3V0IGFuIGV4aXN0aW5nIGNsaWVudFxuICAgICAgY29uc3QgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBwZW5kaW5nIHdhaXRlcnMgYmVjYXVzZVxuICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byBjYWxsIGl0IHdpdGggYSB0aW1lb3V0IGVycm9yXG4gICAgICAgIHJlbW92ZVdoZXJlKHRoaXMuX3BlbmRpbmdRdWV1ZSwgKGkpID0+IGkuY2FsbGJhY2sgPT09IHF1ZXVlQ2FsbGJhY2spXG4gICAgICAgIHBlbmRpbmdJdGVtLnRpbWVkT3V0ID0gdHJ1ZVxuICAgICAgICByZXNwb25zZS5jYWxsYmFjayhuZXcgRXJyb3IoJ3RpbWVvdXQgZXhjZWVkZWQgd2hlbiB0cnlpbmcgdG8gY29ubmVjdCcpKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUXVldWUucHVzaChwZW5kaW5nSXRlbSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICB0aGlzLm5ld0NsaWVudChuZXcgUGVuZGluZ0l0ZW0ocmVzcG9uc2UuY2FsbGJhY2spKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbmV3Q2xpZW50KHBlbmRpbmdJdGVtKSB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IHRoaXMuQ2xpZW50KHRoaXMub3B0aW9ucylcbiAgICB0aGlzLl9jbGllbnRzLnB1c2goY2xpZW50KVxuICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IG1ha2VJZGxlTGlzdGVuZXIodGhpcywgY2xpZW50KVxuXG4gICAgdGhpcy5sb2coJ2NoZWNraW5nIGNsaWVudCB0aW1lb3V0JylcblxuICAgIC8vIGNvbm5lY3Rpb24gdGltZW91dCBsb2dpY1xuICAgIGxldCB0aWRcbiAgICBsZXQgdGltZW91dEhpdCA9IGZhbHNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcykge1xuICAgICAgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdlbmRpbmcgY2xpZW50IGR1ZSB0byB0aW1lb3V0JylcbiAgICAgICAgdGltZW91dEhpdCA9IHRydWVcbiAgICAgICAgLy8gZm9yY2Uga2lsbCB0aGUgbm9kZSBkcml2ZXIsIGFuZCBsZXQgbGlicHEgZG8gaXRzIHRlYXJkb3duXG4gICAgICAgIGNsaWVudC5jb25uZWN0aW9uID8gY2xpZW50LmNvbm5lY3Rpb24uc3RyZWFtLmRlc3Ryb3koKSA6IGNsaWVudC5lbmQoKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKVxuICAgIH1cblxuICAgIHRoaXMubG9nKCdjb25uZWN0aW5nIG5ldyBjbGllbnQnKVxuICAgIGNsaWVudC5jb25uZWN0KChlcnIpID0+IHtcbiAgICAgIGlmICh0aWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpZClcbiAgICAgIH1cbiAgICAgIGNsaWVudC5vbignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nKCdjbGllbnQgZmFpbGVkIHRvIGNvbm5lY3QnLCBlcnIpXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZGVhZCBjbGllbnQgZnJvbSBvdXIgbGlzdCBvZiBjbGllbnRzXG4gICAgICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLmZpbHRlcigoYykgPT4gYyAhPT0gY2xpZW50KVxuICAgICAgICBpZiAodGltZW91dEhpdCkge1xuICAgICAgICAgIGVyci5tZXNzYWdlID0gJ0Nvbm5lY3Rpb24gdGVybWluYXRlZCBkdWUgdG8gY29ubmVjdGlvbiB0aW1lb3V0J1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBjbGllbnQgd29u4oCZdCBiZSByZWxlYXNlZCwgc28gbW92ZSBvbiBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLl9wdWxzZVF1ZXVlKClcblxuICAgICAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKCduZXcgY2xpZW50IGNvbm5lY3RlZCcpXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgIT09IDApIHtcbiAgICAgICAgICBjb25zdCBtYXhMaWZldGltZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlbmRpbmcgY2xpZW50IGR1ZSB0byBleHBpcmVkIGxpZmV0aW1lJylcbiAgICAgICAgICAgIHRoaXMuX2V4cGlyZWQuYWRkKGNsaWVudClcbiAgICAgICAgICAgIGNvbnN0IGlkbGVJbmRleCA9IHRoaXMuX2lkbGUuZmluZEluZGV4KChpZGxlSXRlbSkgPT4gaWRsZUl0ZW0uY2xpZW50ID09PSBjbGllbnQpXG4gICAgICAgICAgICBpZiAoaWRsZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9hY3F1aXJlQ2xpZW50KFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICBuZXcgUGVuZGluZ0l0ZW0oKGVyciwgY2xpZW50LCBjbGllbnRSZWxlYXNlKSA9PiBjbGllbnRSZWxlYXNlKCkpLFxuICAgICAgICAgICAgICAgIGlkbGVMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyAqIDEwMDApXG5cbiAgICAgICAgICBtYXhMaWZldGltZVRpbWVvdXQudW5yZWYoKVxuICAgICAgICAgIGNsaWVudC5vbmNlKCdlbmQnLCAoKSA9PiBjbGVhclRpbWVvdXQobWF4TGlmZXRpbWVUaW1lb3V0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlQ2xpZW50KGNsaWVudCwgcGVuZGluZ0l0ZW0sIGlkbGVMaXN0ZW5lciwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gYWNxdWlyZSBhIGNsaWVudCBmb3IgYSBwZW5kaW5nIHdvcmsgaXRlbVxuICBfYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGlzTmV3KSB7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjbGllbnQpXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdhY3F1aXJlJywgY2xpZW50KVxuXG4gICAgY2xpZW50LnJlbGVhc2UgPSB0aGlzLl9yZWxlYXNlT25jZShjbGllbnQsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nSXRlbS5jYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgTk9PUClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ldyAmJiB0aGlzLm9wdGlvbnMudmVyaWZ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnkoY2xpZW50LCBjbGllbnQucmVsZWFzZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBfcmVsZWFzZSBhbmQgdGhyb3dzIGlmIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICBfcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpIHtcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIChlcnIpID0+IHtcbiAgICAgIGlmIChyZWxlYXNlZCkge1xuICAgICAgICB0aHJvd09uRG91YmxlUmVsZWFzZSgpXG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2VkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbGVhc2UgYSBjbGllbnQgYmFjayB0byB0aGUgcG9sbCwgaW5jbHVkZSBhbiBlcnJvclxuICAvLyB0byByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICBfcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKSB7XG4gICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5fcG9vbFVzZUNvdW50ID0gKGNsaWVudC5fcG9vbFVzZUNvdW50IHx8IDApICsgMVxuXG4gICAgdGhpcy5lbWl0KCdyZWxlYXNlJywgZXJyLCBjbGllbnQpXG5cbiAgICAvLyBUT0RPKGJtYyk6IGV4cG9zZSBhIHByb3BlciwgcHVibGljIGludGVyZmFjZSBfcXVlcnlhYmxlIGFuZCBfZW5kaW5nXG4gICAgaWYgKGVyciB8fCB0aGlzLmVuZGluZyB8fCAhY2xpZW50Ll9xdWVyeWFibGUgfHwgY2xpZW50Ll9lbmRpbmcgfHwgY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgIGlmIChjbGllbnQuX3Bvb2xVc2VDb3VudCA+PSB0aGlzLm9wdGlvbnMubWF4VXNlcykge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGV4cGVuZGVkIGNsaWVudCcpXG4gICAgICB9XG4gICAgICB0aGlzLl9yZW1vdmUoY2xpZW50KVxuICAgICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc0V4cGlyZWQgPSB0aGlzLl9leHBpcmVkLmhhcyhjbGllbnQpXG4gICAgaWYgKGlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5sb2coJ3JlbW92ZSBleHBpcmVkIGNsaWVudCcpXG4gICAgICB0aGlzLl9leHBpcmVkLmRlbGV0ZShjbGllbnQpXG4gICAgICB0aGlzLl9yZW1vdmUoY2xpZW50KVxuICAgICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBpZGxlIHRpbWVvdXRcbiAgICBsZXQgdGlkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcykge1xuICAgICAgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdyZW1vdmUgaWRsZSBjbGllbnQnKVxuICAgICAgICB0aGlzLl9yZW1vdmUoY2xpZW50KVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgICAvLyBhbGxvdyBOb2RlIHRvIGV4aXQgaWYgdGhpcyBpcyBhbGwgdGhhdCdzIGxlZnRcbiAgICAgICAgdGlkLnVucmVmKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgY2xpZW50LnVucmVmKClcbiAgICB9XG5cbiAgICB0aGlzLl9pZGxlLnB1c2gobmV3IElkbGVJdGVtKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aWQpKVxuICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICB9XG5cbiAgcXVlcnkodGV4dCwgdmFsdWVzLCBjYikge1xuICAgIC8vIGd1YXJkIGNsYXVzZSBhZ2FpbnN0IHBhc3NpbmcgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIHRleHQpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCdQYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBwb29sLnF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgcGxhaW4gdGV4dCBxdWVyeSB3aXRob3V0IHZhbHVlc1xuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHZhbHVlc1xuICAgICAgdmFsdWVzID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY2IgPSByZXNwb25zZS5jYWxsYmFja1xuXG4gICAgdGhpcy5jb25uZWN0KChlcnIsIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBsZXQgY2xpZW50UmVsZWFzZWQgPSBmYWxzZVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBjbGllbnQub25jZSgnZXJyb3InLCBvbkVycm9yKVxuICAgICAgdGhpcy5sb2coJ2Rpc3BhdGNoaW5nIHF1ZXJ5JylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudC5xdWVyeSh0ZXh0LCB2YWx1ZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdxdWVyeSBkaXNwYXRjaGVkJylcbiAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICBpZiAoY2xpZW50UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZWxlYXNlZCA9IHRydWVcbiAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgfVxuXG4gIGVuZChjYikge1xuICAgIHRoaXMubG9nKCdlbmRpbmcnKVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYWxsZWQgZW5kIG9uIHBvb2wgbW9yZSB0aGFuIG9uY2UnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cbiAgICB0aGlzLmVuZGluZyA9IHRydWVcbiAgICBjb25zdCBwcm9taXNlZCA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gcHJvbWlzZWQuY2FsbGJhY2tcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICByZXR1cm4gcHJvbWlzZWQucmVzdWx0XG4gIH1cblxuICBnZXQgd2FpdGluZ0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUXVldWUubGVuZ3RoXG4gIH1cblxuICBnZXQgaWRsZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pZGxlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGV4cGlyZWRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5yZWR1Y2UoKGFjYywgY2xpZW50KSA9PiBhY2MgKyAodGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KSA/IDEgOiAwKSwgMClcbiAgfVxuXG4gIGdldCB0b3RhbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pg-pool/index.js\n");

/***/ })

};
;